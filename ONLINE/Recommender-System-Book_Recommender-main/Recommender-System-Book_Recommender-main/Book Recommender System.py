# -*- coding: utf-8 -*-
"""FinalMLT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1g2ZkSB2UbTA3GZbqttUd4hJYKgI0Ec7J

# **Machine Learning Terapan Final Project**

**Book Recommendation System**

Proyek ini berupa sistem rekomendasi buku dengan tujuan akhir yaitu mampu merekomendasikan buku kepada pengguna.   
Secara umum, sistem rekomendasi adalah algoritma yang ditujukan untuk menyarankan item yang relevan kepada pengguna (item seperti film untuk ditonton, buku untuk dibaca, produk untuk dibeli, atau apa pun tergantung pada industri).   
Dalam proyek ini, item yang disarankan adalah buku untuk dibaca dengan rincian dataset sebagai berikut :

1. *Users*  
  Berisi data pengguna. 
  - ID pengguna (User-ID) telah dianonimkan dan dipetakan ke bilangan bulat.  
  - Data demografis (Lokasi, Usia) jika tersedia. Jika tidak, bidang ini berisi nilai NULL.
  
2. *Books*  
  Berisi data buku.   
  - ISBN. ISBN yang tidak valid telah dihapus dari dataset. 
  - Judul Buku, Penulis Buku, Tahun Penerbitan, Penerbit, diperoleh dari Amazon Web Services. Dalam kasus beberapa penulis, hanya nama yang pertama disediakan. 
  - Gambar. URL yang tertaut ke gambar sampul juga diberikan (Image-URL-S, Image-URL-M, Image-URL-L), yaitu kecil, sedang, besar. URL ini mengarah ke situs web Amazon.  

3. *Ratings*  
Berisi informasi *rating* buku. 
  - *Rating (Book-Rating)* bersifat eksplisit, dinyatakan dalam skala 1-10 (nilai yang lebih tinggi menunjukkan apresiasi yang lebih tinggi) atau implisit, yang dinyatakan dengan 0.



https://www.kaggle.com/arashnic/book-recommendation-dataset

# Dataset

Langkah pertama adalah mengimpor dataset yang dibutuhkan. Dataset yang ada, bisa kita upload terlebih dahulu ke Google Drive agar lebih mudah diakses jika menggunakan device yang berbeda karena berbasis cloud.
"""

# Import the Dataset 

from google.colab import drive
drive.mount('/content/drive')

"""Mengekstrak dataset dari bentuk zip"""

# Extracting the Dataset

import zipfile,os
local_zip = '/content/drive/MyDrive/Dicoding/ML Final/Book Recommendation Dataset.zip'
zip_ref = zipfile.ZipFile(local_zip, 'r')
zip_ref.extractall('/tmp')
zip_ref.close()

"""Berikutnya adalah mengimpor libraries yang dibutuhkan"""

# Commented out IPython magic to ensure Python compatibility.
# Importing Libraries

import numpy as np 
import pandas as pd 
from contextlib import contextmanager
from sklearn.neighbors import NearestNeighbors
from scipy.spatial.distance import correlation
from scipy.spatial.distance import correlation, cosine
from sklearn.metrics.pairwise import pairwise_distances
import ipywidgets as widgets
from IPython.display import display, clear_output
import os, sys
import re
from sklearn.metrics import mean_squared_error
from math import sqrt
# %matplotlib inline
import matplotlib.pyplot as plt 
import seaborn as sns
import missingno as mno 
import warnings
warnings.filterwarnings("ignore")

"""Selanjutnya adalah memuat dataset, yaitu Books, Ratings, dan Users"""

# Load the dataset

Books = pd.read_csv('/content/drive/MyDrive/Dicoding/ML Final/Books.csv', low_memory=False)
ratings = pd.read_csv('/content/drive/MyDrive/Dicoding/ML Final/Ratings.csv', low_memory=False)
users = pd.read_csv('/content/drive/MyDrive/Dicoding/ML Final/Users.csv', low_memory=False)

"""# Preliminary Exploration

Setelah mendapatkan dataset, selanjutnya mengekplorasi data terlebih dahulu untuk mendapatkan info mengenai data
"""

# Data Preliminary Exploration

Books.info()

"""Dari data diatas terlihat bahwa dataset Books berisi ISBN, Judul buku, Penulis, Tahun terbit, Penerbit, dan Image"""

ratings.info()

"""Dari data diatas terlihat bahwa dataset Ratings berisi User-ID, ISBN, dan Rating buku"""

users.info()

"""Dari data diatas terlihat bahwa dataset Users berisi User-ID, Lokasi, dan Umur pengguna

Selanjutnya adalah melihat isi dataset
"""

Books.head()

"""# Exploratory Data Analysis"""

Books.columns = ['ISBN', 'BookTitle', 'BookAuthor', 'YearOfPublication', 'Publisher', 'ImageUrlS', 'ImageUrlM', 'ImageUrlL']
ratings.columns = ['userID', 'ISBN', 'Book-Rating']
users.columns = ['userID', 'Location', 'Age']

"""Menghapus kolom yang tidak diperlukan dalam analisis, yaitu image"""

# Dropping last three columns containing image URLs which will not be required for analysis

Books.drop(['ImageUrlS', 'ImageUrlM', 'ImageUrlL'],axis=1,inplace=True)

"""Mengecek apakah ada missing value. Dari hasil diabawah terlihat bahwa tidak ada missing value d dataset Books"""

# Visualize the missing values in the Books 

mno.matrix(Books)

"""
Selanjutnya adalah mengecek apakah ada baris data yang terduplikat pada data Books. Dan dari 217360 baris data terlihat tidak ada baris yang terduplikat"""

# Checking the existence of duplicated rows 

Books.duplicated().sum()

"""  Kita bisa memvisualisasikan penerbit teratas yang paling banyak menerbit buku. Dibawah ini adalah diagram 7 Penerbit Teratas """

# Plotting top publisher

top_publisher=(Books['Publisher'].value_counts()).to_dict()
count= pd.DataFrame(list(top_publisher.items()),columns = ['c','count'])
a = count.sort_values(by=['count'], ascending = False)
a.head(7)
labels = 'Harlequin','Silhouette','Pocket','Ballantine Books','Bantam Books','Scholastic','Simon & Schuster'
sizes = [count['count'].iloc[0],count['count'].iloc[1],count['count'].iloc[2],count['count'].iloc[3],count['count'].iloc[4],
         count['count'].iloc[5],count['count'].iloc[6]]
explode = (0.1, 0.1, 0.1, 0.1,0.1, 0.1,0.1 )
fig1 , ax1 = plt.subplots(figsize=(7,7))
ax1.pie(sizes,
        explode = explode,
        labels = labels,
        autopct = '%1.1f%%',
        shadow = True,
        startangle = 0)
plt.title("Top 7 Publishers With the Most Books")
ax1.axis ('equal')
plt.show()

b = count.sort_values(by=['count'], ascending = False)
b = b.head(20)
x =['Harlequin','Silhouette','Pocket','Ballantine Books','Bantam Books','Scholastic','Simon &amp; Schuster']
y = [7537,4220,3905,3783,3646,3160,2971]
fig=plt.figure(figsize=(10,7))
ax = sns.barplot(x = 'count',y = 'c' , data = b)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90,horizontalalignment='center')
plt.xlabel("No of Books Published", size=14)
plt.ylabel("Publisher", size=14)
plt.title(" Top 20 Publishers With the Most Books", size=18)
for p in ax.patches:
    ax.annotate("%.0f" % p.get_width(), xy=(p.get_width()/2, p.get_y()+p.get_height()/2),
            xytext=(5, 0), textcoords='offset points', ha="left", va="center")
plt.show()

"""# Data Preparation

Pada tahap Data Preparation, kita akan menyiapkan data dari masing-masing fitur, yaitu : ISBN, Judul Buku, Penulis, Rating buku, ID pengguna, Penerbit, dan Tahun terbit.    

Yang pertama adalah kita menggabungkan kolom ISBN yang ada pada dataset Books dan Ratings. Tujuannya adalah agar memudahkan proses mengolah data dan tidak ada data ISBN terduplikat
"""

# Merging dataframe Books and Ratings

Books_Ratings = pd.merge(Books, ratings, on="ISBN")

"""Sehingga kita menyebutnya sekarang adalah Books_Ratings """

Books_Ratings.head()

"""Selanjutnya adalah tahun terbit. 
Kita bisa mengecek terlebih dahulu apakah value dari tahun terbit sudah benar atau belum. 
"""

# Checking Year-Of-Publication values

np.set_printoptions(threshold=np.inf)
Books_Ratings['YearOfPublication'].unique()

"""Dari hasil diatas terlihat bahwa ada wrong value, yaitu tahun yang seharusnya berisi angka malah berisikan tulisan (DK Publishing Inc, Gallimard). Selain itu juga ada wrong value yaitu tahun nya berisikan angka '0' dimana seharusnya berisikan 4 digit tahun. Lalu juga ada tahun yang tidak masuk akal yaitu 2024, 2026, 2030, 2037, 2038, dan 2050.

Mari kita selesaikan permasalahan diatas yaitu dengan mengkonversi wrong value tadi ke dalam 4 digit tahun sebagaimana mestinya
"""

# Convert wrong value to int in Year-Of-Publication

index=Books_Ratings.loc[Books_Ratings['YearOfPublication']=='DK Publishing Inc'].index
Books_Ratings.drop(index,inplace=True)
index=Books_Ratings.loc[Books_Ratings['YearOfPublication']=='Gallimard'].index
Books_Ratings.drop(index,inplace=True)
Books_Ratings['YearOfPublication'].unique()

Books_Ratings.YearOfPublication=Books_Ratings.YearOfPublication.astype(np.int32)

# Setting invalid years as NaN
Books_Ratings.loc[(Books_Ratings.YearOfPublication > 2006) | (Books_Ratings.YearOfPublication == 0),'YearOfPublication'] = np.NAN

# Replacing NaNs with mean value of Year-Of-Publication
Books_Ratings.YearOfPublication.fillna(round(Books_Ratings.YearOfPublication.mean()), inplace=True)

"""Setelah memperbaiki value dari tahun terbit, selanjutnya kita bisa melihat apakah tahun nya sudah terisi dengan 4 digit angka dan ternyata sudah berhasil diubah"""

# Recheck

Books_Ratings['YearOfPublication'].unique()

"""Kita juga bisa memvisualisasikan data tahun terbit melalui histogram dari tahun terbit 1970 sampai dengan tahun 2021"""

# Plotting Years of Publication

fig=plt.figure(figsize=(8,5))
y1 = Books_Ratings[Books_Ratings['YearOfPublication'] >= 1970]
y1 = y1[y1['YearOfPublication'] <= 2021]
sns.distplot(y1['YearOfPublication'])
plt.xlabel('Year Of Publication',size=14)
plt.title('Histogram of the Year of Publication',size=16)
plt.show()

"""Dari histogram diatas, tahun paling populer dalam penerbitan buku adalah antara tahun 2000-2005

Fitur selanjutnya adalah rating buku. Rating bersifat eksplisit dinyatakan dalam skala 1-10 (nilai yang lebih tinggi menunjukkan apresiasi yang lebih tinggi) atau implisit, yang dinyatakan dengan 0.

**Ratings Dataset**
"""

ratings['Book-Rating'].unique()

# Checking rows

ratings.head()

# Ratings dataset should have books only which exist in our books dataset, unless new books are added to books dataset

ratings_new = ratings[ratings.ISBN.isin(Books.ISBN)]

ratings = ratings[ratings.userID.isin(users.userID)]

print(ratings.shape)
print(ratings_new.shape)

"""Lalu kita memisahkan rating eksplisit dan implisit karena kita hanya akan menggunakan yang eksplisit (dimulai dari 1) dan bukan implisit (0)"""

# Segragating implicit and explicit ratings datasets

ratings_explicit = ratings_new[ratings_new['Book-Rating'] != 0]
ratings_implicit = ratings_new[ratings_new['Book-Rating'] == 0]

# Checking shapes

print(ratings_new.shape)
print(ratings_explicit.shape)
print(ratings_implicit.shape)

"""Dan kita memvisualisasikan rating buku untuk melihat angka berapa yang sering pengguna berikan dalam menilai buku"""

print(ratings.shape)
print(ratings_explicit.shape)
print(ratings_implicit.shape)
plt.style.use('fivethirtyeight')
plt.figure(figsize=(8, 6))
sns.countplot(data=ratings_explicit , x='Book-Rating', palette='magma')

"""Selanjutnya kita mengidentifikasi data Users

**Users Dataset**
"""

users.head()

"""Terlihat di bagian 'Age' masih ada missing value. Kita akan melihat lebih jauh data umur dari pengguna"""

users['Age'].unique()

"""Dari hasil diatas, ternyata selain NaN, ada juga umur yang kurang masuk akal yaitu dibawah 5 tahun dan diatas 90 tahun bahkan sampai umur 200an tahun. Maka seperti tahun terbit tadi, kita akan mengubah nya menjadi NaN dan kemudian NaN akan diubah menjadi nilai rata-rata dari Age. """

# Setting invalid Age as NaN
users.loc[(users.Age < 5) | (users.Age > 90),'Age'] = np.NAN

# Replacing NaNs with mean value of Age
users.Age.fillna(round(users.Age.mean()), inplace=True)

users.Age=users.Age.astype(np.int32)

# Recheck Age

users['Age'].unique()

"""Dari hasil diatas, data Umur sudah terlihat lebih bagus dan masuk akal

# Data Modelling 

Pada pemodelan, kita akan menggunakan metode Collaborative Filtering dengan pendekatan Item Based dan User Based menggunakan algoritma K-Nearest Neighbors

**Collaborative Filtering Based Recommendation System** 

Setelah data sudah selesai dipersiapkan, maka selanjutnya adalah memasuki proses pemodelan. 
Selanjutnya kita menggunakan Collaborative Filtering dengan algoritma K-Nearest Neighbours. Algoritma KNN menggunakan ‘kesamaan fitur’ untuk memprediksi nilai dari setiap data yang baru. Dengan kata lain, setiap data baru diberi nilai berdasarkan seberapa mirip titik tersebut dalam set pelatihan.

Karena data buku nya sangat banyak dan bisa mempengaruhi kinerja model, maka kita perkecil ruang lingkup dengan memakai variabel rating explicit yang sudah kita definisikan di Data Preparation tadi. Ruang lingkup nya yaitu rating explicit dari pengguna yang sudah memberikan rating terhadap minimal 100 buku serta buku yang sudah dirating sebanyak minimal 200 kali, sehingga ruang lingkup nya menjadi lebih kecil untuk melatih model
"""

counts_new = ratings_explicit['userID'].value_counts()
ratings_explicit = ratings_explicit[ratings_explicit['userID'].isin(counts_new[counts_new >= 100].index)]
counts = ratings_explicit['Book-Rating'].value_counts()
ratings_explicit = ratings_explicit[ratings_explicit['Book-Rating'].isin(counts[counts >= 200].index)]

"""Selanjutnya adalah membuat matriks rating dari rating explicit dan mengatasi NaN values"""

matrix_ratings = ratings_explicit.pivot(index='userID', columns='ISBN', values='Book-Rating')
userID = matrix_ratings.index
ISBN = matrix_ratings.columns
print(matrix_ratings.shape)
matrix_ratings.fillna(0, inplace = True)
matrix_ratings = matrix_ratings.astype(np.int32)
matrix_ratings.head()

"""Menentukan variabel global dimana parameter k kita beri nilai 10 """

global metric,k
k=10
metric='cosine'

"""**User Based Recommendation System**

Pada model KNN ini, kita memakai 2 pendekatan yaitu User based dan Item based.  User based adalah pendekatan yang menghasilkan rekomendasi dari pengguna lain yang memiliki selera yang sama.  
Dengan menggunakan algortime "brute" untuk mencari tetangga terdekat dan mengepaskan model dengan mencari kesamaannya kepada buku serupa yang sudah diberi rating untuk direkomendasikan kepada pengguna.
"""

def findksimilarusers(user_id, ratings, metric = metric, k=k):
    similarities=[]
    indices=[]
    model_knn = NearestNeighbors(metric = metric, algorithm = 'brute') 
    model_knn.fit(ratings)
    loc = ratings.index.get_loc(user_id)
    distances, indices = model_knn.kneighbors(ratings.iloc[loc, :].values.reshape(1, -1), n_neighbors = k+1)
    similarities = 1-distances.flatten()
            
    return similarities,indices

"""Selanjutnya adalah kita mencoba mencari prediksi rating dari sebuah buku kepada pengguna. Matriks rating yang tadi sudah kita buat akan digunakan dalam training prediksi ini. Format nya adalah User ID, Item ID (buku) dan prediksi rating. Dimana matriks nya tadi juga didesain serupa, yaitu User ID, nomor ISBN, dan rating buku. Sehingga dengan memanfaatkan matriks rating tersebut kita bisa memprediksi rating buku. """

def predict_userbased(user_id, item_id, ratings, metric = metric, k=k):
    prediction=0
    user_loc = ratings.index.get_loc(user_id)
    item_loc = ratings.columns.get_loc(item_id)
    similarities, indices=findksimilarusers(user_id, ratings,metric, k) 
    mean_rating = ratings.iloc[user_loc,:].mean() 
    sum_wt = np.sum(similarities)-1
    product=1
    wtd_sum = 0 
    
    for i in range(0, len(indices.flatten())):
        if indices.flatten()[i] == user_loc:
            continue;
        else: 
            ratings_diff = ratings.iloc[indices.flatten()[i],item_loc]-np.mean(ratings.iloc[indices.flatten()[i],:])
            product = ratings_diff * (similarities[i])
            wtd_sum = wtd_sum + product
    
    if prediction <= 0:
        prediction = 1   
    elif prediction >10:
        prediction = 10
    
    prediction = int(round(mean_rating + (wtd_sum/sum_wt)))
    print ("Predicted rating for user {0} -> item {1}: {2}".format(user_id,item_id,prediction))

    return prediction

"""Dari hasil dibawah terlihat bahwa buku ber-ISBN : 0060938455 diprediksi rating nya kepada pengguna dengan User ID 105979 dan 11676, masing-masing 1 dan 2. Semakin besar hasil prediksi rating diharapkan bisa menjadi rekomendasi kepada pengguna."""

predict_userbased(105979,'0060938455',matrix_ratings);
predict_userbased(11676,'0060938455',matrix_ratings);

"""**Item Based Recommendation System**

Pendekatan selanjutnya adalah dengan Item Based. Item based filtering bekerja dengan cara menghitung kesamaan antara masing-masing item. Jika user based adalah rekomendasi berdasarkan kesamaan pengguna, maka item based adalah rekomendasi berdasarkan kesamaan item. 

Kita akan melakukan hal yang sama seperti pada user based yaitu mencari kesamaan (similarities).
"""

def findksimilaritems(item_id, ratings, metric=metric, k=k):
    similarities=[]
    indices=[]
    ratings=ratings.T
    loc = ratings.index.get_loc(item_id)
    model_knn = NearestNeighbors(metric = metric, algorithm = 'brute')
    model_knn.fit(ratings)
    
    distances, indices = model_knn.kneighbors(ratings.iloc[loc, :].values.reshape(1, -1), n_neighbors = k+1)
    similarities = 1-distances.flatten()

    return similarities,indices

"""Kita akan menguji dengan mencari kesamaan pada item yang memiliki ISBN 0060938455"""

similarities,indices=findksimilaritems('0060938455',matrix_ratings)

"""Selanjutnya kita nenbuat prediksi dengan menggunakan matriks rating yang kita buat tadi dan item ID (nomor ISBN). Format prediksi nya sama seperti tadi yaitu User ID, nomor ISBN, dan prediksi rating. Perbedaan dalam mencari prediksi rating dari user based dan item based adalah dalam user based, prediksi rating yang diberikan juga dipengaruhi oleh nilai rating dikurangi rata-rata rating karena untuk mencari item yang direkomendasikan, user based mengambil data rata-rata dari pengguna lain yang memberikan rating pada buku. Sedangkan pada item based hanya dipengaruhi oleh rating buku karena lebih berfokus pada kesamaan item."""

def predict_itembased(user_id, item_id, ratings, metric = metric, k=k):
    prediction= wtd_sum =0
    user_loc = ratings.index.get_loc(user_id)
    item_loc = ratings.columns.get_loc(item_id)
    similarities, indices=findksimilaritems(item_id, ratings) 
    sum_wt = np.sum(similarities)-1
    product=1
    for i in range(0, len(indices.flatten())):
        if indices.flatten()[i] == item_loc:
            continue;
        else:
            product = ratings.iloc[user_loc,indices.flatten()[i]] * (similarities[i])
            wtd_sum = wtd_sum + product                              
    prediction = int(round(wtd_sum/sum_wt))
    
    if prediction <= 0:
        prediction = 1   
    elif prediction >10:
        prediction = 10
 
    print ("Predicted rating for user {0} -> item {1}: {2}".format(user_id,item_id,prediction))     
    
    return prediction

"""Kita akan mencoba Item Based dengan ISBN yang sama digunakan tadi dan dengan user ID yang sebelumnya jga kita gunakan dengan masing-masing prediksi rating 1 dan 9. """

predict_itembased(105979,'0060938455',matrix_ratings);
predict_itembased(11676,'0060938455',matrix_ratings);

@contextmanager
def suppress_stdout():
    with open(os.devnull, "w") as devnull:
        old_stdout = sys.stdout
        sys.stdout = devnull
        try:  
            yield
        finally:
            sys.stdout = old_stdout

"""Selanjutnya adalah memberikan rekomendasi kepada user berdasarkan pendekatan User based atau Item based. 
Pada dasarnyya ini adalah satu model yaitu KNN namun menggunakan 2 pendekatan yang berbeda tergantung kebutuhan. Jika ingin memberikan rekomendasi berdasarkan apa buku yang juga dibaca oleh orang lain, maka menggunakan User based. Namun jika ingin mencari buku yang serupa maka menggunakan Item based.   

Untuk metrik yang digunakan juga menggunakan 2 metrik yaitu cosine dan correlation. Cosine adalah metrik yang digunakan untuk menghitung kesamaan dalam 2 sampel sedangkan correlation menghitung korelasi antar 2 variabel acak. 
"""

def recommendItem(user_id, ratings, metric=metric):    
    if (user_id not in ratings.index.values) or type(user_id) is not int:
        print ("User id should be a valid integer from this list :\n\n {} ".format(re.sub('[\[\]]', '', np.array_str(matrix_ratings.index.values))))
    else:    
        ids = ['Item-based (correlation)','Item-based (cosine)','User-based (correlation)','User-based (cosine)']
        select = widgets.Dropdown(options=ids, value=ids[0],description='Select approach', width='1000px')
        def on_change(change):
            clear_output(wait=True)
            prediction = []            
            if change['type'] == 'change' and change['name'] == 'value':            
                if (select.value == 'Item-based (correlation)') | (select.value == 'User-based (correlation)') :
                    metric = 'correlation'
                else:                       
                    metric = 'cosine'   
                with suppress_stdout():
                    if (select.value == 'Item-based (correlation)') | (select.value == 'Item-based (cosine)'):
                        for i in range(ratings.shape[1]):
                            if (ratings[str(ratings.columns[i])][user_id] !=0): #not rated already
                                prediction.append(predict_itembased(user_id, str(ratings.columns[i]) ,ratings, metric))
                            else:                    
                                prediction.append(-1) #for already rated items
                    else:
                        for i in range(ratings.shape[1]):
                            if (ratings[str(ratings.columns[i])][user_id] !=0): #not rated already
                                prediction.append(predict_userbased(user_id, str(ratings.columns[i]) ,ratings, metric))
                            else:                    
                                prediction.append(-1) #for already rated items
                prediction = pd.Series(prediction)
                prediction = prediction.sort_values(ascending=False)
                recommended = prediction[:10]
                print ("As per {0} approach....Following books are recommended...".format(select.value))
                for i in range(len(recommended)):
                     print ("{0}. {1}".format(i+1,Books.BookTitle[recommended.index[i]].encode('utf-8')))                        
        select.observe(on_change)
        display(select)

recommendItem(10000, matrix_ratings)

"""Pada tahap ini, jika diimplementasikan hanya akan menggunakan satu pendekatan saja, item based atau user based. Tetapi karena kita ingin melihat perbedaan keduanya kita bisa mencoba pendekatan yang kita mau """

recommendItem(105979, matrix_ratings)

recommendItem(105979, matrix_ratings)

"""Dari hasil diatas sudah terlihat jelas bahwa Item Based dan User Based menghasilkan rekomendasi yang berbeda meskipun menggunakan metrik yang sama karena item based dan user based mencari rekomendasi berdasarkan kebutuhan pengguna. """

recommendItem(105979, matrix_ratings)

"""Sedangkan dari hasil diatas, User based yang menggunakan 2 metrik (cosine dan correlation) memperoleh rekomendasi yang sama.

# Model Evaluation

Pada tahap evaluasi model, kita akan mengevaluasi model KNN dari pendekatan yang kita pilih atas user ID dan ISBN yang sama seperti sebelumnya.
"""

def evaluateRS(ratings):
    ids = ['User-based CF (cosine)','User-based CF (correlation)','Item-based CF (cosine)','Item-based CF (correlation)']
    approach = widgets.Dropdown(options=ids, value=ids[0],description='Select Approach', width='500px')
    n_users = ratings.shape[0]
    n_items = ratings.shape[1]
    prediction = np.zeros((n_users, n_items))
    prediction= pd.DataFrame(prediction)
    def on_change(change):
        clear_output(wait=True)
        with suppress_stdout():
            if change['type'] == 'change' and change['name'] == 'value':            
                if (approach.value == 'User-based CF (cosine)'):
                    metric = 'cosine'
                    for i in range(n_users):
                        for j in range(n_items):
                            prediction[i][j] = predict_userbased(105979, '0060938455', ratings, metric)
                elif (approach.value == 'User-based CF (correlation)')  :                       
                    metric = 'correlation'               
                    for i in range(n_users):
                        for j in range(n_items):
                            prediction[i][j] = predict_userbased(105979, '0060938455', ratings, metric)
                elif (approach.value == 'Item-based CF (cosine)'):
                    for i in range(n_users):
                        for j in range(n_items):
                            prediction[i][j] = predict_userbased(105979, '0060938455', ratings)
                else:
                    for i in range(n_users):
                        for j in range(n_items):
                            prediction[i][j] = predict_userbased(105979, '0060938455', ratings)
              
        MSE = mean_squared_error(prediction, ratings)
        RMSE = round(sqrt(MSE),3)
        print ("RMSE using {0} approach is: {1}".format(approach.value,RMSE))
              
    approach.observe(on_change)
    display(approach)

evaluateRS(matrix_ratings)

"""Mungkin dikarenakan pada dasarnya hanyalah satu model saja yaitu KNN meskipun menggunakan pendekatan yang berbeda, model hanya bisa dievaluasi dari salah satu pendekatan. 
Saya sudah mencoba untuk mengevaluasi Item Based dan User Based namun model mengeluarkan hasil evaluasi hanya pada satu pendekatan saja. Sebaliknya jika saya memilih pendekatan lain, model tetap menghasilkan output evaluasi yang sama pada pendekatan yang dpilih sebelumnya. 
"""